Date: 10/12/2024
Day : Tuesday 

sdlc(software Development Life Cycle):
The Software Development Life Cycle (SDLC) is a structured process used for developing software applications. 
It involves several phases, each with specific tasks and objectives.
The goal of the SDLC is to produce high-quality software that meets or exceeds customer expectations, reaches completion within times and cost estimates, and works efficiently and effectively in the current and planned IT infrastructure.

Planning:                                                                  1)planning

Define project goals, scope, and constraints.                              2)Requirements Analysis
Conduct feasibility studies.
Develop a project plan, including timelines and resources.                 3)Design

Requirements Analysis:                                                     4)Implementation

Gather and analyze user and stakeholder requirements.                      5)Testing
Document functional and non-functional requirements.
Create use cases and user stories.                                         6)Deployment

Design:                                                                    7)Maintenance

Architect the overall system and software structure.                       8)Evaluation
Create detailed designs for components, modules, and interfaces.
Develop data models and design databases.

Implementation (Coding):

Write the actual code based on the design specifications.
Perform unit testing to ensure individual components work correctly.

Testing:

Conduct various levels of testing (e.g., integration, system, acceptance).
Identify and fix defects and bugs.
Ensure the software meets the specified requirements.

Deployment:

Release the software to the production environment.
Ensure proper installation and configuration.
Train users and provide documentation.

Maintenance:

Monitor the software for any issues.
Perform regular updates and bug fixes.
Enhance the software with new features as required.

Evaluation (optional):

Review the project's success and the software's performance.
Gather feedback from users and stakeholders.
Document lessons learned and best practices for future projects.(exe files,packages can't see the code,The code is not given to the client)
-------------------------------------------------------------------------------------------------
Agile and Waterfall are two distinct methodologies used in project management and software development. 

Waterfall Model(after the completion of the project the issue will be find outed)
---------------------------------------
Waterfall is a Sequential Process:

1)Follows a linear and sequential approach.
2)Each phase must be completed before the next one begins.
---------------------------------------------
Phases:
Requirements : write document and send to client
Design
Implementation
Verification
Maintenance

Documentation:Has to be sined up 
Extensive documentation is created before starting the development phase.
Changes are difficult and costly to implement after the project has started.

Testing:
Performed only after the development phase is complete.
Issues found late can be more costly to fix.

Flexibility:
Less flexible and adaptive(planning,development etc...) to changes.
Best suited for projects with well-defined requirements and minimal expected changes.
---------------------------------------------------------------------------------------------------------------------------------
Agile Model
Iterative(like loop) and Incremental Process:

Focuses on iterative development, with cycles called sprints (typically 2-4 weeks).
Each iteration delivers a potentially shippable product increment.

Phases:
Involves continuous cycles of planning, designing, coding, testing, and reviewing.

Documentation:
Less emphasis on documentation, more focus on working software.
Documentation evolves as the project progresses.

Project Scope:
Scope can evolve as the project progresses.
Allows for changes based on stakeholder feedback and market demands.

Testing:(they want product to be completed)
Continuous testing throughout the development process.
Issues are identified and resolved early, reducing the cost of fixing them.

Flexibility:
Highly flexible and adaptive to changes.
Ideal for projects with dynamic requirements and a need for rapid delivery.
------------------------------------------------------------------------------------------------------------
Key Differences
Approach: Waterfall is linear and sequential(one after another), while Agile is iterative and incremental(the extra features are added).
Flexibility: Waterfall is rigid and less adaptable to changes, whereas Agile is flexible and adaptive.
Documentation: Waterfall requires extensive documentation(long process) upfront; Agile focuses on minimal documentation with evolving requirements.
Testing: Waterfall conducts testing after development; Agile integrates testing throughout the development process.
Customer Involvement: Waterfall involves customers mainly at the beginning and end, while Agile involves customers continuously.
------------------------------------------------------------------------------------------------------------------------------

Waterfall(example construction of house): Suitable for projects with well-defined requirements, minimal expected changes, and where a sequential process is more effective (e.g., construction projects).
Agile: Suitable for projects with dynamic requirements, a need for flexibility, and rapid delivery (e.g., software development, tech startups).
Each methodology has its strengths and is suited to different types of projects and organizational environments.

PROTOTYPE:
A prototype model is an  early-stage representation or version of a system,product,or concept,built to test and validate ideas,gather feedback,or demonstrate functionality.
It helpsnstakeholders visualize the final design and identify areas for improvement before full-scale development.
The terem can apply to various fields,including engineering,design,software development,and business.

Characteristics of a prototype model:
Simplified Version: Focuses on key functionalities rather than full details.
Iterative: Can evolve based on feedback and testing.
Low-Cost: Uses minimal resources compared to the final product.
Feedback-Oriented: Designed to elicit user input for refinements

Types of Prototypes:
1)Throwaway Prototypes: Built quickly and discarded after feedback.
2)Evolutionary Prototypes: Improved iteratively to evolve into the final product.
3)Functional Prototypes: Mimic specific features or operations.
4)Conceptual Prototypes: Focus on visualizing ideas rather than functionality.

Applications:
1)Engineering: Test mechanical or structural concepts.
2)Software Development: Test user interfaces or algorithms (e.g., mockups, wireframes).
3)Product Design: Create physical models of products (e.g., 3D printing).
4)Business: Develop business models or service prototypes.

***(IMPORTANT)what is advantage of proper planning in SDLC---->
Clarity of Objectives and Scope,
Risk Management,
Resource Allocation and Management,
Timeline and Milestone Definition,
Quality Assurance and Testing Strategy,
Stakeholder Engagement and Communication,
Cost Management,
Adaptability and Flexibility
-----------------------------------------------------------------
What are different types of Prototype models :- 
1)Throwaway/Rapid Prototypes,
2)Evolutionary Prototypes,
3)Incremental Prototypes,
4)Extreme Prototyping

Q3)When will frontend and backend developers both involved in SDLC development phase
-----------------------------------------------------------------------------------------
Q4)The Adaptive Maintenance phase in the Software Development Life Cycle (SDLC) refers to the process of modifying a software system to keep it usable in a changing environment. This involves making changes and enhancements to software to ensure it continues to operate correctly as the external environment evolves. These changes can be triggered by new business requirements, technological advancements, legislative changes, or user feedback.
---------------------------------------------------------------------------------------------
Q5)A prototyping model is a software development approach that involves creating an incomplete version of the software program being developed. This prototype is then used to visualize and understand the requirements, refine functionalities, and gather feedback from users and stakeholders early in the development process.
-------------------------------------------------------------------------------------------


***Some Questions based on flowcharts

Binary search we have to insert the data in ascending order 
the best time complexity of binary search is O(1)
the best time complexity of linear search is O(n) where n is the no of elements in the list
the best time complexity of bubble sort is O(
------------------------------------------------------------------------------------------------------------------------------------------------------------
Date : 11/12/2024
Day  : Wednesday

Github:to save the data,it is a secure place,we can access it,All the project work is uploaded,in the local system it may crash
Git&github belongs to development & operation.
Build is a exe file,it is a green means okay with color,if it is another any color the problem will come.
all the data is pulled to the data puller
I is insert
Git Status:upload the file in global
It uses many commands like this push add insert etc..,
to add more files like 10 and above git.add init

Git :- githhub(central),  git(local)
---------------------------------------------------------------------------
Git is distributed reposistory.
-----------------------------------------
1)central repository
step to create central Repository
i)https://github.com
ii)sign up and sign in
iii)karthick10oct@yahoo.co.in
iv)password :-karthick123
v)user:-karthick2018
-------------------------------------------
public :- every one can view it
private :- it paid version $7 per month
--------------------------------------------
vi)submit
vii)start a project
----------------------------------
2)after signin
give the repository name

---------------------------------------------------------------
2)local repository
1) http://git-scm.com/download
and install...
-----------------------------------------------------------------------------------------------------
2)create a folder
right click on the folder
select (Git gui here)
a cmd prompt will open
-------------------------------------
3)to link the local repository to remote repository (1st step)
-> git remote add origin "https://github.com/sandipmohapatra/lgstudents"(near code copy the url and paste as here)

-------------------------------------------------------------------
4)to pull the data from remote repository
----------------------------------------------------------
->git pull origin master (2nd step) (check the branch name master or some other name in your github)
-----------------------------------------------------------------------------------
1s -1 ---->create the files
vi test.txt
----------------------------------------------------------------
5)git status(it will be in green color) :- tells you which files are added to index and are ready to commit.
------------------------------------------------------------------------------------------------
6)git add:-lets you to add files to your index.
----------------------------------------------------------------------------------
7)git commit:- it refers to recording snapshots of the repository at a given time.
committed snapshots will never change unless done explicitly.
-----------------------------------------------------------------------------------------------------------
8)create a text file in local then see the status(first.txt) git branch 
----------------------------------------------------------
9)git add first.txt
----------------------------------------------
 10)again see the status
-----------------------------------
$ git config --global user.email "sandipmohapatra.sandipmohapatra123@gmail.com"
---------------------------------------------------------------------------------------------
$ git config --global user.name "sandipmohapatra.sandipmohapatra"
--------------------------------------------------------------------------------------------
11)git commit -m "this is the first file in local repository" (m stands for message)
------------------------------------------------------------------------------------
12)git log (to see the log files) (date & time,whatever we have done today etc..,)
-------------------------------------------------------------------------------------------
13)Parallel Development - Banching
Branches are pointer to a specific commit.
 banches are of two types
1)local branches
2)Remote tracking branches.
----------------------------------------------
14)to create a branch(doing work separately separately)
git branch firstbranch(Your Name)
--------------------------------------------------------------
15)switch from master branch to firstbranch
git checkout firstbranch
----------------------------------------------------
create some more files then
1)git add text5.txt
2)git commit -m "make change in first branch"
-----------------------------------------------------------------
16)ls 
will show all the files in the firstbranch
----------------------------------------------
17)to change to master
git checkout master
----------------------------------------------
18)Parallel Development -merging
it is a way to combine the work of different branches together
allows to branch off,develop a new feature and combine it back in.
------------------------------
git merge firstbranch
firstbranch will merge with the master branch
------------------------------------------------------
19)go back to the firstbranch
git checkout firstbranch
------------------------------------------
*again modify the all the files 
then commit all the changes

git commit -a -m "modified files"
all the files will be added to index and commited
--------------------------------------------------
cat text4.txt
view the file content
--------------------------------------------------------
again goto the master branch and again view the content
cat text4.txt
--------------------------------------------------------
Then merge it to add the diffence.
----------------------------------------------------------
Parallel development --rebasing
This is also a way of combining the work between different branches.
It can be used to make a linear sequence of commits.
clean project history 
-------------------------------------------------------------------------
git checkout firstbranch
*create some more files
git add -A
---------------------------------------------------
git commit -a -m "adding for rebashing"
-------------------------------------------------
git rebase master
git rebase firstbranch (all the files added to master)
--------------------------------------------------------
push changes to center repository
--------------------------------------------------------
1)create ssh key (logging or processing the data),Encrypted & Decrypted key will be there.
ssh-keygen
---------------------------------------------
overwrite(y)
* the key will be stored in /c/Users/sandip/.ssh/id_rsa.pub
--------------------------------------------------------
2)see the ssh key
cat   /c/Users/sandip/.ssh/id_rsa.pub
---------------------------------------------------------------
3)go to setting at the top where we have (profile,logout)
4)goto SSH and GPG keys
5)click on New SSH Key
6)add title and paste the key
7)click on Add SSH Key
-----------------------------------------------------
go to the git
goto your branch
git checkout firstbranch
------------------------------------------
to push to the github
-------------------------------------
11)git push origin firstbranch(It is push to the global)
----------------------------------------------
12)git checkout master
13)git push origin master
---------------------------------------------
GitHub.com ----gobal repository
git---local repository
--------------------------------------------------



NEXT TOPIC
----------------------------------------------------------------------------------------------------------------------------------------------------
Memory management in Java is handled through an automatic process known as Garbage Collection (GC), which is responsible for reclaiming memory that is no longer in use by the program. Here’s an overview of how memory management works in Java:

1. Memory Allocation
Java applications use two main types of memory allocation:

Stack Memory:

Used for static memory allocation.
Stores primitive data types (e.g., int, float) and references to objects.
Each thread has its own stack, which stores method calls, local variables, and references.

-----------------------------------------------------------------------------------------
Heap Memory:

Used for dynamic memory allocation.
Stores objects and arrays.
Shared among all threads of an application.
-----------------------------------------------------------------------------------------

2. Garbage Collection (GC)
GC is the process of automatically reclaiming memory by identifying and discarding objects that are no longer reachable in the application. 
----------------------------------------------------------------
4. Memory Leaks
Although Java handles memory management automatically, memory leaks can still occur if references to unused objects are not cleared. Common causes of memory leaks include:

Static fields holding references to objects.
Unclosed resources (e.g., file handles, network connections).
Long-lived collections with objects that are no longer needed.

5. Best Practices for Memory Management
Minimize object creation: Reuse objects when possible.
Use appropriate data structures: Choose the right data structure for the job.
Close resources: Ensure resources are properly closed in a finally block or use try-with-resources.
Monitor and profile: Use profiling tools to monitor memory usage and identify memory leaks.


Conclusion

Effective memory management in Java is crucial for building efficient and reliable applications. By understanding how the JVM handles memory and following best practices, developers can minimize the risk of memory leaks and optimize the performance of their applications.
---------------------------------------------------------------------------------------------------------------------------------------------------------
Binary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing in half the portion of the list that could contain the item, until you've narrowed down the possible locations to just one.
----------------------------------------------------------------------------------------------------------------------
4 5 6 7 8 10 12
----------------------------------------------------------------------------
public class BinarySearch 
{
    // Returns the index of key if it is present in array[], else return -1
    public static int binarySearch(int[] array, int key) {
        int left = 0, right = array.length - 1;
        while (left <= right) 
{
            int mid = left + (right - left) / 2;

            // Check if key is present at mid
            if (array[mid] == key)
                return mid;

            // If key greater, ignore left half
            if (array[mid] < key)
                left = mid + 1;

            // If key is smaller, ignore right half
            else
                right = mid - 1;
        }

        // Key was not present in the array
        return -1;
    }

    public static void main(String[] args) {
        int[] array = {2, 3, 4, 10, 40};
        int key = 10;
        int result = binarySearch(array, key);
        if (result == -1)
            System.out.println("Element not present in array");
        else
            System.out.println("Element found at index " + result);
    }
}
-------------------------------------------------------------------------------------------------------------------
Initialization:

left is the starting index (0).
right is the ending index (array.length - 1).
Loop until the search space is empty (left <= right):

Calculate the middle index: mid = left + (right - left) / 2.
If the middle element is the key, return the middle index.
If the key is greater than the middle element, narrow the search to the right half (left = mid + 1).
If the key is smaller than the middle element, narrow the search to the left half (right = mid - 1).
If the element is not found, return -1.

Usage
The example in the main method shows how to use the binarySearch method. It searches for the key 10 in the array {2, 3, 4, 10, 40} and prints the result.
----------------------------------------------------------------------------------------------------------------------
linear search in java
Linear search is a straightforward algorithm for finding a specific element in a list. It works by sequentially checking each element of the list until the desired element is found or the list is exhausted.

public class LinearSearch 
{
    // Returns the index of key if it is present in array[], else return -1
    public static int linearSearch(int[] array, int key) {
        for (int i = 0; i < array.length; i++) {
            if (array[i] == key)
                return i;
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] array = {2, 3, 4, 10, 40};
        int key = 10;
        int result = linearSearch(array, key);
        if (result == -1)
            System.out.println("Element not present in array");
        else
            System.out.println("Element found at index " + result);
    }
}
----------------------------------------------------------------------------------------------------------------------

Loop through each element of the array:
The loop runs from the first element (index 0) to the last element (index array.length - 1).
Check each element:
If the current element array[i] is equal to the key, return the index i.
If the element is not found, return -1:
If the loop completes without finding the key, return -1 indicating the element is not present in the array.
Usage
The example in the main method demonstrates how to use the linear Search method. It searches for the key 10 in the array {2, 3, 4, 10, 40} and prints the result.
---------------------------------------------------------------------------------------------------------------
Bubble Sort
---------------------
public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        boolean swapped;
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // Swap arr[j] and arr[j+1]
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }
            // If no two elements were swapped by inner loop, then the array is sorted
            if (!swapped) {
                break;
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("Unsorted array:");
        printArray(arr);

        bubbleSort(arr);
        
        System.out.println("Sorted array:");
        printArray(arr);
    }

    public static void printArray(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}
--------------------------------------------------------------------------------------------------------------------
public class MergeSort {

    // Merges two subarrays of arr[].
    // First subarray is arr[l..m]
    // Second subarray is arr[m+1..r]
    public static void merge(int arr[], int left, int mid, int right) {
        // Find sizes of two subarrays to be merged
        int n1 = mid - left + 1;
        int n2 = right - mid;

        // Create temp arrays
        int leftArray[] = new int[n1];
        int rightArray[] = new int[n2];

        // Copy data to temp arrays
        for (int i = 0; i < n1; ++i)
            leftArray[i] = arr[left + i];
        for (int j = 0; j < n2; ++j)
            rightArray[j] = arr[mid + 1 + j];

        // Merge the temp arrays

        // Initial indexes of first and second subarrays
        int i = 0, j = 0;

        // Initial index of merged subarray array
        int k = left;
        while (i < n1 && j < n2) {
            if (leftArray[i] <= rightArray[j]) {
                arr[k] = leftArray[i];
                i++;
            } else {
                arr[k] = rightArray[j];
                j++;
            }
            k++;
        }

        // Copy remaining elements of leftArray[] if any
        while (i < n1) {
            arr[k] = leftArray[i];
            i++;
            k++;
        }

        // Copy remaining elements of rightArray[] if any
        while (j < n2) {
            arr[k] = rightArray[j];
            j++;
            k++;
        }
    }

    // Main function that sorts arr[l..r] using merge()
    public static void mergeSort(int arr[], int left, int right) {
        if (left < right) {
            // Find the middle point
            int mid = (left + right) / 2;

            // Sort first and second halves
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);

            // Merge the sorted halves
            merge(arr, left, mid, right);
        }
    }

    // A utility function to print array of size n
    public static void printArray(int arr[]) {
        int n = arr.length;
        for (int i = 0; i < n; ++i)
            System.out.print(arr[i] + " ");
        System.out.println();
    }

    // Main method to test above
    public static void main(String args[]) {
        int arr[] = { 12, 11, 13, 5, 6, 7 };

        System.out.println("Given Array");
        printArray(arr);

        mergeSort(arr, 0, arr.length - 1);

        System.out.println("\nSorted array");
        printArray(arr);
    }
}
----------------------------------------------------------------------------------------------------------
Explanation
merge() Method:

Merges two subarrays of arr[].
First subarray is arr[l..m].
Second subarray is arr[m+1..r].
mergeSort() Method:

Recursively sorts the array by dividing it into halves and calling mergeSort() on each half.
Finally, it merges the sorted halves using the merge() method.
printArray() Method:

Prints the elements of the array.
Main Method:

Initializes an array.
Prints the unsorted array.
Calls mergeSort() to sort the array.
Prints the sorted array.

Given Array
12 11 13 5 6 7 

Sorted array
5 6 7 11 12 13 
--------------------------------------------------------------------------
Quick sort
-------------------
Quick Sort
Quick Sort is a highly efficient sorting algorithm and is based on the divide-and-conquer approach. It works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively.

Steps in Quick Sort
Choose a Pivot: Pick an element from the array as the pivot (commonly the first, last, or middle element, or a random element).
Partitioning: Reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it.
Recursively Apply: Recursively apply the above steps to the sub-arrays of elements with smaller and greater values.
Pseudocode
Here's a simple pseudocode for Quick Sort:
----------------------------------------------------------------------------------------------------------------
procedure quickSort(A, low, high)
    if low < high
        pivotIndex = partition(A, low, high)
        quickSort(A, low, pivotIndex - 1)
        quickSort(A, pivotIndex + 1, high)

procedure partition(A, low, high)
    pivot = A[high]
    i = low - 1
    for j = low to high - 1
        if A[j] < pivot
            i = i + 1
            swap A[i] with A[j]
    swap A[i + 1] with A[high]
    return i + 1
----------------------------------------------------------------------------------------------------------
public class QuickSort {

    // This method takes last element as pivot, places
    // the pivot element at its correct position in sorted
    // array, and places all smaller elements to left of
    // pivot and all greater elements to right of pivot
    public static int partition(int arr[], int low, int high) {
        int pivot = arr[high];
        int i = (low - 1); // index of smaller element
        for (int j = low; j < high; j++) {
            // If current element is smaller than or equal to pivot
            if (arr[j] <= pivot) {
                i++;

                // swap arr[i] and arr[j]
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }

        // swap arr[i+1] and arr[high] (or pivot)
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        return i + 1;
    }

    // The main function that implements QuickSort
    // arr[] --> Array to be sorted,
    // low --> Starting index,
    // high --> Ending index
    public static void quickSort(int arr[], int low, int high) {
        if (low < high) {
            // pi is partitioning index, arr[pi] is now at right place
            int pi = partition(arr, low, high);

            // Recursively sort elements before
            // partition and after partition
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    // A utility function to print array of size n
    public static void printArray(int arr[]) {
        int n = arr.length;
        for (int i = 0; i < n; ++i)
            System.out.print(arr[i] + " ");
        System.out.println();
    }

    // Main method to test the QuickSort
    public static void main(String args[]) {
        int arr[] = {10, 7, 8, 9, 1, 5};
        int n = arr.length;

        System.out.println("Unsorted array:");
        printArray(arr);

        quickSort(arr, 0, n - 1);

        System.out.println("Sorted array:");
        printArray(arr);
    }
}
Explanation
partition() Method:

This method selects the last element as the pivot.
It places all elements smaller than the pivot to the left and all greater elements to the right.
It returns the partitioning index.
quickSort() Method:

This method recursively sorts the sub-arrays before and after the partitioning index.
printArray() Method:

Prints the elements of the array.
Main Method:

Initializes an array.
Prints the unsorted array.
Calls quickSort() to sort the array.
Prints the sorted array.
Unsorted array:
10 7 8 9 1 5 
Sorted array:
1 5 7 8 9 10 

--------------------------------------------------------------------------
Binary Search
-------------------------------------------------------------------------
The time complexity of binary search is O(log n), where n is the number of elements in the array. This logarithmic time complexity means that the search time increases slowly as the size of the array grows. 
Binary search is more efficient than linear search, which has a time complexity of O(n). Binary search works by:
Reducing the search space by half at each step
Checking if the middle-most element matches the target
Performing binary search on a subarray of size at most n/2 if the middle element does not match the target. Continuing recursively until the subarray is empty

*The best-case time complexity of binary search is O(1) when the central index directly matches the desired value.
-----------------------------------------------------------------------
Linear search
-----------------------------------------------------------------------
The time complexity of linear search is O(n), where n is the number of elements in the list. This means that the time it takes for the algorithm to execute is linearly dependent on the size of the input. As the size of the input increases, so does the time it takes for the algorithm to execute. 

The time complexity of linear search algorithms is O(n), where n is the number of elements in the list. It is used for smaller datasets and the data set is unsorted.
---------------------------------------------------------------------------------------------
Bubble sort
----------------------------------------------------------------------------------------------
Bubble sort has a time complexity of O(N2) which makes it very slow for large data sets. Bubble sort is a comparison-based sorting algorithm, which means that it requires a comparison operator to determine the relative order of elements in the input data set.

The time complexity of bubble sort in Java is:
Worst-case: O(n^2)
Average-case: O(n^2)
Best-case: O(n)
--------------------------------------------------------------------------
Selection sort
--------------------------------------------------------------------------
The time complexity of selection sort in Java is O(n^2) in all cases (best, average, and worst).
This is because:
The outer loop iterates through the array n times to find the minimum element in the unsorted part.
The inner loop iterates through the unsorted part of the array (which decreases in size with each iteration of the outer loop) to find the minimum element.
Regardless of the input data, selection sort always performs the same number of comparisons.
Therefore, the overall time complexity is O(n^2).
--------------------------------------------------------------------------------------
Quick Sort
----------------------------------------------------------------------------------------
Best case: O(n log n) - This occurs when the pivot consistently divides the array into two roughly equal halves.

Average case: O(n log n) - This is the expected performance for most inputs.

Worst case: O(n^2) - This occurs when the pivot selection consistently results in unbalanced partitions, such as when the array is already sorted or nearly sorted.
----------------------------------------------------------------------------------------------
Quick Sort
----------------------------
In the best and average cases, the algorithm divides the array into halves at each recursion level, resulting in a logarithmic number of levels (log n). At each level, the algorithm performs O(n) operations to partition the array. Therefore, the total time complexity becomes O(n log n).
In the worst case, the pivot selection always results in one partition with a single element and another partition with the remaining elements. This leads to a linear number of recursion levels (n). At each level, the algorithm still performs O(n) operations. Hence, the total time complexity becomes O(n^2).

The time complexity of Quick Sort is O(n log n) on average case, but can become O(n^2) in the worst-case
-------------------------------------------------------------------------------------------------------
Merge sort
--------------------
The time complexity of merge sort in Java, and in any other language, is O(n log n) for all cases: best, average, and worst. 
This means that the number of operations required to sort an array of size n grows logarithmically with n.

The time complexity of merge sort is O(n*Log n) for all cases (best, average and worst).
--------------------------------------------------------------------------------------------------
Insertion Sort
------------------------
The time complexity of insertion sort in Java is the same as in any other language:
Best case: O(n) - When the array is already sorted.
Average case: O(n²) - When the array is randomly ordered.
Worst case: O(n²) - When the array is in reverse order.

Insertion sort is a simple and efficient algorithm for small input sizes or partially sorted data. It has a time complexity of O(n^2) in the worst case and O(n) in the best case. It is a stable sorting algorithm that maintains the relative order of equal elements.
-------------------------------------------------------------------------------------------------


https://dev.mysql.com/downloads/installer/
-------------------------------------------------------------------------------------------
https://github.com/sandipmohapatra/MLA237JavaSM
-------------------------------------------------------------------------------------------
Mysql notes
----------------------------------------------------
To see the databases
1)show databases;
-----------------------------------------------------
to create database
2)create database daimler;
--------------------------------------------------------
to goto the database
3)use daimler;
-------------------------------------------------------------------------------------------
to create table
create table student (rollno int, name varchar(30),address varchar(30));
---------------------------------------------------------------------------------------------
to insert data into the table
insert into student values(101,'sandip','Bangalore');
insert into student values(102,'Rohan','Bangalore');
-------------------------------------------------------------------------
 to view the data 
select * from student;
----------------------------------------------------------------------------
create table employee (empno int,name varchar(30),address varchar(30));
to add some more columns
alter table student add phy int;
alter table student add bio int;
alter table student add chem int;
alter table student add tot int;
alter table student add avg int;
update student set phy=88,chem=83,bio=74 where rollno=101;
update student set phy=78,chem=73,bio=84 where rollno=102;
update student set phy=68,chem=63,bio=64 where rollno=103;
update student set phy=78,chem=73,bio=84 where rollno=102;
update student set tot=phy+chem+bio ;
update student set avg=tot/3;
----------------------------------------------------------------------------
to delete a row
delete from student where rollno=101;
-----------------------------------------------------------------------------
to drop a table
drop table student;
----------------------------------------------------------------------------------
to drop a database
drop database Mphasis237;
--------------------------------------------------------------------------------------------
delete all the rows or data but the structure of the table will be there
truncate table student;
-------------------------------------------------------------------------------------------
to update a row
update student set address='pune' where rollno=101;




Date: 12-12-2024
Day : Thursday

Foreign Key : refer to another table
primary key: no duplicate,not null

on delete cascade: force fully delete the cascade,if the parent is deleted,the child also deleted.























